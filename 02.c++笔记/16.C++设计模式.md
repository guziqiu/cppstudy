设计模式：在一定环境下，用固定套路解决问题



#  1.设计模式



## 1.设计模式种类

GoF提出的设计模式有23个，包括：

创建型模式：如何创建对象

结构型模式：如何实现类或对象的组合

行为型模式：类或对象怎样交互以及怎样分配职责



简单工厂模式不属于GoF23中设计模式



设计模式目前的种类：GoF23种 + 简单工厂模式 = 24种



## 2.设计模式有什么用



更加深入理解面向对象的思想，知道：

如何将代码分散在几个不通的类中？

为什么要有接口？

何谓针对抽象编程？

何时不应该使用继承？

如何不修改源代码增加新功能？

更好地阅读和理解现有类库和其他系统中的源代码？



## 3.如何学好设计模式

设计模式的基础：多态





简单工厂模式



# 2.面向对象设计原则

对于面向对象软件系统的设计而言，两个重要的问题

1.支持可维护性

2.提高系统的可复用性

面向对象设计原则为支持可维护性复用而生，这些原则蕴含在很多设计模式中，他们是从许多设计方案中总结出的指导性原则。

> 原则的目的 ：高内聚、低耦合



面向对象原则表



| 名称                                                     | 定义                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| 单一职责原则<br />(Single Responsibility Principle,SRP)  | 类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个 |
| 开闭原则<br />(Open-Closed Principle, OCP)               | 类的改动是通过增加代码进行的，而不是修改源代码               |
| 里氏代还原则<br />(Liskov Substitution Principle,LSP)    | 任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能 |
| 依赖倒转原则<br />(Dependece Inversion Principle, DOP)   | 依赖于抽象接口，不要依赖具体的实现类，也就是针对接口编程     |
| 接口隔离原则<br />(Interface Segregation Principle, ISP) | 不应该强迫用户的程序依赖他们不需要的接口方法，一个接口应该改只提供一种对外的功能，不应该把所有的操作都封装到一个接口中去。 |
| 合成复用原则<br />(Composite Reuse Principle, CRP)       | 如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合. |
| 迪米特法则<br />(Law of Demeter, LoB)                    | 一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部发生改变事，不会影响其他模块的使用。（黑盒原理） |



## 1.开闭原则代码示例

```cpp
#include <iostream>
using namespace std;
// 开闭原则 对扩展开放，对修改关闭，增加功能是通过增加代码进行实现的,而不是修改代码

// 抽象类 计算器

class AbstractCaculator
{
public :
	virtual int getResult() = 0;
	virtual void setop(int a, int b) = 0;
};

// 加法

class Plus : public AbstractCaculator
{

public:
	virtual void setop(int a, int b)
	{
		this->m_a = a;
		this->m_b = b;
	}
	virtual int getResult()
	{
		return this->m_a + m_b;
	}

	int m_a;
	int m_b;
};

// 减法

int main() {

	AbstractCaculator *cal = new Plus;
	cal->setop(10, 20);
	cout << cal->getResult() << endl;


	return 0;
}

```



## 2.迪米特法则代码实例

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

// 最少知识原则  又叫最少知识原则

class AbstrBuild
{
public :
	virtual void sale() = 0;
public:
	string m_qulity;
};


class buildA : public AbstrBuild
{
public :
	buildA()
	{
		m_qulity = "high";
	}

	virtual void sale()
	{
		cout << m_qulity << " is saled" << endl;
	}

	// string m_qulity;
};

class buildB : public AbstrBuild
{
public :
	buildB()
	{
		m_qulity = "low";
		// cout << m_qulity << endl;
	}

	virtual void sale()
	{
		cout << m_qulity << "is saled" << endl;
	}

	// string m_qulity;
};

class mediator
{
public:
	mediator()
	{
		AbstrBuild *b = new buildA;
		v_b.push_back(b);

		b = new buildB;
		v_b.push_back(b);
	}
	~mediator()
	{
		for (vector<AbstrBuild *>::iterator it = v_b.begin();
			it != v_b.end(); ++it)
			{
				if (*it != NULL)
				{
					delete *it;
				}
			}
	}

	// 对外提供接口
	AbstrBuild *findMyBuild(string q)
	{
		for (vector<AbstrBuild *>::iterator it = v_b.begin();
			it != v_b.end(); ++it)
		{
			if ((*it)->m_qulity == q)
			{
				return *it;
			}
		}
		return NULL;
	}

	vector<AbstrBuild *> v_b;
};


int main() {
	// 1
	AbstrBuild *a = new buildA;
	cout << a->m_qulity << endl;
	if (a->m_qulity == "high")
	{
		a->sale();
	}

	AbstrBuild *b = new buildB();
	if (b->m_qulity == "low")
	{
		b->sale();
	}

	// 
	mediator *me = new mediator;
	AbstrBuild *bu = me->findMyBuild("high");
	if (NULL != bu)
	{
		bu->sale();
	}

	return 0;
}

```





## 3.合成复用原则案例

继承和组合优先使用组合

```cpp
#include <iostream>
using namespace std;

// 
class AbsCar
{
public:
	virtual void run() = 0;
};

// dahzong
class dazhong : public AbsCar
{
public:
	virtual void run()
	{
		cout << "da zhong ..." << endl;
	}
};

class dahuangfeng : public AbsCar
{
public:
	virtual void run()
	{
		cout << "da zhong ..." << endl;
	}
};

class person : public dahuangfeng, public dazhong
{
	// s
};

class person2
{
public:
	void SetCar(AbsCar *car)
	{
		this->car = car;
	}
	void run()
	{
		car->run();
	}
	~person2()
	{
		delete car;
	}
public:
	AbsCar *car;
};

int main() {
	person2 p;
	p.SetCar(new dahuangfeng);
	p.run();

	return 0;
}

```





## 4.依赖倒转原则

```cpp
#include <iostream>
using namespace std;

// 底层
class BankWorker {
public :
	void saveService() {
		cout << "存款..." << endl;
	}
	void payService() {
		cout << "支付..." << endl;
	}
	void tracnferService() {
		cout << "转账..." << endl;
	}
};

// 中层模块
void doSaveBussiness(BankWorker *worker) {
	worker->saveService();
}

void doPayService(BankWorker *worker) {
	worker->payService();
}
void doTracnferService(BankWorker *worker) {
	worker->tracnferService();
}

// 高层
void test01() {
	BankWorker *worker = new BankWorker;
	doSaveBussiness(worker);
	doPayService(worker);
	doTracnferService(worker);
}

// 
class AbstractWorker {
public :
	virtual void dbBusiness() = 0;
};

// 存款
class SaveBankWorkrt : public AbstractWorker {
public :
	virtual void dbBusiness() {
		cout << " 办理存款业务 ..." << endl;
	}
};
// 专门办理付款
class payBankWorker : public AbstractWorker {
	virtual void dbBusiness() {
		cout << " 支付业务 ..." << endl;
	}
};
// 。。。。

// 中层业务
void doNewBusiness(AbstractWorker *worker) {
	worker->dbBusiness();
}

void test02() {
	AbstractWorker *pay = new payBankWorker();
	doNewBusiness(pay);
	doNewBusiness(new SaveBankWorkrt());
}

int main() {
	// test01();
	test02();

	return 0;
}

```



# 简单工厂模式

## 1.优点

1.客户端和具体实现类解耦

2.对于某些对象创建过程比较复杂的情况，我们不需要考虑



## 2.缺点

1.简单工厂模式，增加新的功能需要修改源代码，不符合开闭原则

2.这个类的职责过重，这个类发生问题，会影响很多使用这个工厂的模块



# 创建者模型



# 结构性模型

# 行为型模型







# 单例模式

全局只有一个对象

>如何实现单例：
>
>1.构造函数私有化
>
>2.增加静态私有化的当前类的指针变量
>
>3.提供一个静态的对外接口，让用户可以获得单例对象



```cpp
#include <iostream>
using namespace std;

class A {

private :
	A() {}

public :
	static A* getInstace()
	{
		return a;
	}
private :
	static A *a;
};

int main() {
	A::getInstace();

	return 0;
}
```







`单例分为懒汉式 和 饿汉式`



> 单例对象释放问题
> 不需要考虑



## 1.懒汉式



```cpp
// 懒汉式
class singleton_lazy {
private :
	singleton_lazy() { plazy = nullptr;}
public : 
	static singleton_lazy *getInstace()
	{
		if (nullptr == plazy)
		{
			plazy = new singleton_lazy();
		}
		return plazy;
	}
private :
	static singleton_lazy *plazy;
};

// 类外初始化
singleton_lazy* singleton_lazy::plazy = nullptr;

int main() {
	singleton_lazy *p1 = singleton_lazy::getInstace();
	singleton_lazy *p2 = singleton_lazy::getInstace();

	if (p1 == p2)
	{
		cout << "same memory, is singleton" << endl;
	}
	else{
		cout << "not singleton" << endl;
	}
	return 0;
}
```



## 2.饿汉式



```cpp
// 饿汉式

class singleton_hungry {
private :
	singleton_hungry() { pHungry = nullptr; cout << "i am hungry!\n" << endl;}
public : 
	static singleton_hungry *getInstace()
	{
		return pHungry;
	}
#if 0
	// 不合适
	static void freeSpace()
	{
		if (pHungry != NULL)
		{
			delete pHungry;
		}
	}
#endif
	class garbo {
		~garbo()
		{
			if (pHungry != nullptr)
			{
				delete pHungry;
			}
		}
	};
private :
	static singleton_hungry *pHungry;
	static garbo garbo;
};

// 类外初始化
singleton_hungry* singleton_hungry::pHungry = new singleton_hungry;

int main() {
	singleton_hungry *p3 = singleton_hungry::getInstace();
	singleton_hungry *p4 = singleton_hungry::getInstace();
	if (p3 == p4)
	{
		cout << "same memory, is singleton" << endl;
	}
	else{
		cout << "not singleton" << endl;
	}

	return 0;
}

```

